# =============================================================================
# OLLAMA LLM VALIDATION SERVICE - Simple Working Version
# =============================================================================

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: ollama-config
  namespace: crypto-trading
data:
  OLLAMA_HOST: "0.0.0.0"
  OLLAMA_PORT: "11434"
  OLLAMA_DEFAULT_MODEL: "phi3:3.8b"
  SERVICE_PORT: "8050"
  OLLAMA_URL: "http://ollama:11434"

---
# Ollama Core Service - LLM Runtime
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ollama
  namespace: crypto-trading
  labels:
    app: ollama
    component: llm-runtime
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: ollama
  template:
    metadata:
      labels:
        app: ollama
        component: llm-runtime
    spec:
      containers:
      - name: ollama
        image: ollama/ollama:latest
        ports:
        - containerPort: 11434
          name: http
        env:
        - name: OLLAMA_HOST
          valueFrom:
            configMapKeyRef:
              name: ollama-config
              key: OLLAMA_HOST
        - name: OLLAMA_PORT
          valueFrom:
            configMapKeyRef:
              name: ollama-config
              key: OLLAMA_PORT
        volumeMounts:
        - name: ollama-models
          mountPath: /root/.ollama
        resources:
          requests:
            memory: "4Gi"
            cpu: "1000m"
          limits:
            memory: "8Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /
            port: 11434
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /api/tags
            port: 11434
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        startupProbe:
          httpGet:
            path: /
            port: 11434
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 10
      volumes:
      - name: ollama-models
        hostPath:
          path: /tmp/ollama-models
          type: DirectoryOrCreate

---
apiVersion: v1
kind: Service
metadata:
  name: ollama
  namespace: crypto-trading
  labels:
    app: ollama
spec:
  selector:
    app: ollama
  ports:
  - name: http
    port: 11434
    targetPort: 11434
  type: ClusterIP

---
# Ollama LLM Validation Service - Simple Version
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ollama-llm-validation
  namespace: crypto-trading
  labels:
    app: ollama-llm-validation
    component: llm-validation
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ollama-llm-validation
  template:
    metadata:
      labels:
        app: ollama-llm-validation
        component: llm-validation
    spec:
      containers:
      - name: ollama-llm-validation
        image: python:3.11-slim
        imagePullPolicy: Never
        ports:
        - containerPort: 8050
          name: http
        command: ["/bin/bash"]
        args:
        - -c
        - |
          pip install fastapi uvicorn mysql-connector-python requests aiohttp
          
          cat > /app/service.py << 'EOF'
          import os
          import logging
          import time
          import json
          import requests
          import aiohttp
          import asyncio
          import mysql.connector
          from datetime import datetime, timedelta
          from fastapi import FastAPI, HTTPException
          import uvicorn
          import threading
          
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
          logger = logging.getLogger(__name__)
          
          app = FastAPI(title='Ollama LLM Validation Service')
          OLLAMA_URL = os.getenv('OLLAMA_URL', 'http://ollama:11434')
          DEFAULT_MODEL = os.getenv('OLLAMA_DEFAULT_MODEL', 'phi3:3.8b')
          
          def get_db_connection():
              try:
                  db_config = {
                      'host': os.getenv('DB_HOST', '172.22.32.1'),
                      'user': os.getenv('DB_USER', 'news_collector'),
                      'password': os.getenv('DB_PASSWORD'),
                      'database': os.getenv('DB_NAME_PRICES', 'crypto_prices')
                  }
                  return mysql.connector.connect(**db_config)
              except Exception as e:
                  logger.error(f'Database connection failed: {e}')
                  return None
          
          async def check_ollama_models():
              try:
                  async with aiohttp.ClientSession() as session:
                      async with session.get(f'{OLLAMA_URL}/api/tags', timeout=10) as response:
                          if response.status == 200:
                              data = await response.json()
                              models = [model['name'] for model in data.get('models', [])]
                              logger.info(f'Available Ollama models: {models}')
                              return models
                          else:
                              logger.warning(f'Failed to get Ollama models: {response.status}')
                              return []
              except Exception as e:
                  logger.error(f'Error checking Ollama models: {e}')
                  return []
          
          def fallback_validation(recommendation, market_context):
              symbol = recommendation['symbol']
              signal_type = recommendation['signal_type']
              confidence = recommendation['confidence']
              amount = recommendation['amount_usd']
              
              validation_score = 0.0
              reasoning_parts = []
              
              if confidence > 0.7:
                  validation_score += 0.3
                  reasoning_parts.append('High confidence signal')
              elif confidence > 0.5:
                  validation_score += 0.2
                  reasoning_parts.append('Moderate confidence signal')
              else:
                  reasoning_parts.append('Low confidence signal')
              
              rsi = market_context.get('rsi', 50)
              if signal_type == 'BUY' and rsi < 70:
                  validation_score += 0.2
                  reasoning_parts.append('RSI not overbought')
              elif signal_type == 'SELL' and rsi > 30:
                  validation_score += 0.2
                  reasoning_parts.append('RSI not oversold')
              
              sentiment = market_context.get('sentiment', 'neutral')
              if sentiment == 'bullish' and signal_type == 'BUY':
                  validation_score += 0.2
                  reasoning_parts.append('Bullish sentiment supports buy')
              elif sentiment == 'bearish' and signal_type == 'SELL':
                  validation_score += 0.2
                  reasoning_parts.append('Bearish sentiment supports sell')
              
              if amount <= 100:
                  validation_score += 0.1
                  reasoning_parts.append('Reasonable trade size')
              elif amount > 1000:
                  validation_score -= 0.2
                  reasoning_parts.append('Large trade size - high risk')
              
              if validation_score >= 0.6:
                  validation = 'APPROVE'
              elif validation_score >= 0.3:
                  validation = 'MODIFY'
                  suggested_amount = amount * 0.5
              else:
                  validation = 'REJECT'
                  suggested_amount = 0.0
              
              if validation_score >= 0.7:
                  risk = 'LOW'
              elif validation_score >= 0.4:
                  risk = 'MEDIUM'
              else:
                  risk = 'HIGH'
              
              return {
                  'validation': validation,
                  'confidence': min(1.0, max(0.0, validation_score)),
                  'reasoning': '; '.join(reasoning_parts),
                  'risk_assessment': risk,
                  'suggested_amount': suggested_amount if validation == 'MODIFY' else amount
              }
          
          def get_market_context(symbol):
              conn = get_db_connection()
              if not conn:
                  return {}
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  cursor.execute('''
                      SELECT current_price, volume_24h, rsi, crypto_sentiment, vix, sentiment_score
                      FROM ml_features_materialized 
                      WHERE symbol = %s 
                      ORDER BY timestamp_iso DESC 
                      LIMIT 1
                  ''', (symbol,))
                  data = cursor.fetchone()
                  
                  if data:
                      return {
                          'symbol': symbol,
                          'current_price': data['current_price'],
                          'volume_24h': data['volume_24h'],
                          'rsi': data['rsi'],
                          'sentiment': data['crypto_sentiment'],
                          'vix': data['vix'],
                          'sentiment_score': data['sentiment_score']
                      }
                  return {}
              except Exception as e:
                  logger.error(f'Error getting market context for {symbol}: {e}')
                  return {}
              finally:
                  if conn:
                      conn.close()
          
          def validate_recommendation(recommendation_id):
              conn = get_db_connection()
              if not conn:
                  return None
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  cursor.execute('SELECT * FROM trade_recommendations WHERE id = %s', (recommendation_id,))
                  recommendation = cursor.fetchone()
                  
                  if not recommendation:
                      return None
                  
                  market_context = get_market_context(recommendation['symbol'])
                  validation_result = fallback_validation(recommendation, market_context)
                  
                  cursor.execute('''
                      UPDATE trade_recommendations 
                      SET llm_validation = %s,
                          llm_confidence = %s,
                          llm_reasoning = %s,
                          risk_assessment = %s,
                          suggested_amount = %s,
                          validation_timestamp = NOW()
                      WHERE id = %s
                  ''', (
                      validation_result['validation'],
                      validation_result['confidence'],
                      validation_result['reasoning'],
                      validation_result['risk_assessment'],
                      validation_result['suggested_amount'],
                      recommendation_id
                  ))
                  
                  conn.commit()
                  logger.info(f'Validated recommendation {recommendation_id}: {validation_result["validation"]}')
                  return validation_result
                  
              except Exception as e:
                  logger.error(f'Error validating recommendation {recommendation_id}: {e}')
                  return None
              finally:
                  if conn:
                      conn.close()
          
          def validate_pending_recommendations():
              conn = get_db_connection()
              if not conn:
                  return
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  cursor.execute('''
                      SELECT id FROM trade_recommendations 
                      WHERE execution_status = 'PENDING'
                      AND (llm_validation IS NULL OR llm_validation = '')
                      AND created_at >= NOW() - INTERVAL 30 MINUTE
                      ORDER BY created_at DESC
                      LIMIT 5
                  ''')
                  
                  recommendations = cursor.fetchall()
                  validated_count = 0
                  for rec in recommendations:
                      result = validate_recommendation(rec['id'])
                      if result:
                          validated_count += 1
                  
                  logger.info(f'Validated {validated_count} recommendations')
                  
              except Exception as e:
                  logger.error(f'Error in validation cycle: {e}')
              finally:
                  if conn:
                      conn.close()
          
          @app.get('/health')
          def health_check():
              return {
                  'status': 'healthy',
                  'service': 'ollama_llm_validation',
                  'ollama_url': OLLAMA_URL,
                  'default_model': DEFAULT_MODEL,
                  'timestamp': datetime.now().isoformat()
              }
          
          @app.post('/validate/{recommendation_id}')
          async def validate_endpoint(recommendation_id: int):
              result = validate_recommendation(recommendation_id)
              if result:
                  return result
              else:
                  raise HTTPException(status_code=404, detail='Recommendation not found or validation failed')
          
          @app.get('/status')
          def get_status():
              conn = get_db_connection()
              if not conn:
                  return {'status': 'unhealthy', 'error': 'Database not connected'}
              
              try:
                  cursor = conn.cursor()
                  cursor.execute('''
                      SELECT COUNT(*) FROM trade_recommendations 
                      WHERE execution_status = 'PENDING'
                      AND (llm_validation IS NULL OR llm_validation = '')
                  ''')
                  pending_validation = cursor.fetchone()[0]
                  
                  cursor.execute('''
                      SELECT COUNT(*) FROM trade_recommendations 
                      WHERE llm_validation = 'APPROVE'
                      AND execution_status = 'PENDING'
                  ''')
                  approved_pending = cursor.fetchone()[0]
                  
                  return {
                      'status': 'healthy',
                      'pending_validation': pending_validation,
                      'approved_pending': approved_pending,
                      'ollama_url': OLLAMA_URL,
                      'timestamp': datetime.now().isoformat()
                  }
              except Exception as e:
                  return {'status': 'unhealthy', 'error': str(e)}
              finally:
                  if conn:
                      conn.close()
          
          @app.on_event('startup')
          async def startup_event():
              logger.info('Starting Ollama LLM Validation Service...')
              
              available_models = await check_ollama_models()
              if available_models:
                  logger.info(f'Connected to Ollama with models: {available_models}')
              else:
                  logger.warning('No Ollama models available, will use fallback validation')
              
              def validation_worker():
                  while True:
                      try:
                          validate_pending_recommendations()
                          time.sleep(60)
                      except Exception as e:
                          logger.error(f'Error in validation worker: {e}')
                          time.sleep(60)
              
              threading.Thread(target=validation_worker, daemon=True).start()
              logger.info('Ollama LLM Validation Service started')
          
          if __name__ == '__main__':
              uvicorn.run(app, host='0.0.0.0', port=8050)
          EOF
          
          python /app/service.py
        envFrom:
        - configMapRef:
            name: ollama-config
        - configMapRef:
            name: trade-exec-coinbase-config
        env:
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: trade-exec-coinbase-secrets
              key: DB_PASSWORD
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8050
          initialDelaySeconds: 30
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 8050
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3

---
apiVersion: v1
kind: Service
metadata:
  name: ollama-llm-validation
  namespace: crypto-trading
  labels:
    app: ollama-llm-validation
spec:
  selector:
    app: ollama-llm-validation
  ports:
  - name: http
    port: 8050
    targetPort: 8050
  type: ClusterIP
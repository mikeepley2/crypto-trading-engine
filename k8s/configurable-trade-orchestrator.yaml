apiVersion: apps/v1
kind: Deployment
metadata:
  name: configurable-trade-orchestrator
  namespace: crypto-trading
  labels:
    app: configurable-trade-orchestrator
    component: trading-automation
spec:
  replicas: 1
  selector:
    matchLabels:
      app: configurable-trade-orchestrator
  template:
    metadata:
      labels:
        app: configurable-trade-orchestrator
    spec:
      containers:
      - name: orchestrator
        image: python:3.11-slim
        command: ["/bin/bash", "-c"]
        args:
        - |
          pip install mysql-connector-python requests &&
          cd /app &&
          python simple_trade_orchestrator.py
        workingDir: /app
        env:
        # Production-safe configuration - only fresh recommendations
        - name: MAX_AGE_MINUTES
          value: "15"  # Only execute recommendations 15 minutes or newer
        - name: MAX_TRADES_PER_CYCLE
          value: "3"   # Limit trades per cycle for safety
        - name: CHECK_INTERVAL_SECONDS
          value: "30"  # Check every 30 seconds
        - name: PYTHONUNBUFFERED
          value: "1"
        volumeMounts:
        - name: orchestrator-code
          mountPath: /app
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          exec:
            command:
            - python
            - -c
            - "import os; print('Orchestrator healthy')"
          initialDelaySeconds: 30
          periodSeconds: 60
        readinessProbe:
          exec:
            command:
            - python
            - -c
            - "import mysql.connector; print('Dependencies ready')"
          initialDelaySeconds: 10
          periodSeconds: 30
      volumes:
      - name: orchestrator-code
        configMap:
          name: orchestrator-code
      restartPolicy: Always
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: orchestrator-code
  namespace: crypto-trading
data:
  simple_trade_orchestrator.py: |
    #!/usr/bin/env python3
    """
    Configurable Trade Orchestrator - Production Ready
    
    Executes trades only on fresh AI recommendations within configurable time windows.
    Replaces the broken signal processing bridge with a robust, safe solution.
    """
    
    import os
    import sys
    import time
    import json
    import logging
    import argparse
    import requests
    import mysql.connector
    from decimal import Decimal
    from datetime import datetime
    
    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)
    
    class SimpleTradeOrchestrator:
        def __init__(self, max_age_minutes=None, max_trades_per_cycle=None, check_interval=None):
            # Database configuration - auto-detect host for Docker vs direct execution
            import socket
            try:
                # Try to connect to host.docker.internal first (for Docker/WSL environments)
                socket.create_connection(('host.docker.internal', 3306), timeout=2).close()
                db_host = 'host.docker.internal'
            except:
                # Fall back to localhost for direct execution
                db_host = 'localhost'
            
            self.db_config = {
                'host': db_host,
                'user': 'news_collector',
                'password': '99Rules!',
                'database': 'crypto_transactions'
            }
            self.trade_api_url = 'http://trade-exec-coinbase:8024/execute_trade'
            
            # Configurable parameters with environment variable fallbacks
            self.max_age_minutes = max_age_minutes or int(os.getenv('MAX_AGE_MINUTES', '15'))
            self.max_trades_per_cycle = max_trades_per_cycle or int(os.getenv('MAX_TRADES_PER_CYCLE', '3'))
            self.check_interval = check_interval or int(os.getenv('CHECK_INTERVAL_SECONDS', '30'))
            
        def get_fresh_recommendations(self):
            """Get fresh trade recommendations using proper timezone handling"""
            try:
                conn = mysql.connector.connect(**self.db_config)
                cursor = conn.cursor(dictionary=True)
                
                # Query for fresh, unprocessed recommendations using timezone-aware filtering
                query = """
                SELECT id, symbol, action, amount_usd, confidence, entry_price, current_price, 
                       reasoning, created_at, signal_id, model_confidence
                FROM trade_recommendations 
                WHERE created_at >= DATE_SUB(NOW(), INTERVAL %s MINUTE)
                AND status = 'pending'
                AND amount_usd > 0
                ORDER BY confidence DESC, created_at DESC
                LIMIT %s
                """
                
                cursor.execute(query, (self.max_age_minutes, self.max_trades_per_cycle))
                recommendations = cursor.fetchall()
                
                # Convert datetime and decimal objects for JSON compatibility
                for rec in recommendations:
                    if rec['created_at']:
                        rec['created_at'] = rec['created_at'].isoformat()
                    for key, value in rec.items():
                        if isinstance(value, Decimal):
                            rec[key] = float(value)
                
                cursor.close()
                conn.close()
                
                logger.info(f"üìä Found {len(recommendations)} fresh recommendations (within {self.max_age_minutes}m)")
                return recommendations
                
            except Exception as e:
                logger.error(f"‚ùå Error getting recommendations: {e}")
                return []
        
        def execute_trade(self, recommendation):
            """Execute a trade via the trade execution engine API"""
            try:
                # Convert symbol to Coinbase format
                symbol = recommendation['symbol']
                if '-USD' not in symbol:
                    symbol = f"{symbol}-USD"
                
                trade_data = {
                    "symbol": symbol,
                    "action": recommendation['action'],
                    "size_usd": float(recommendation['amount_usd']),
                    "order_type": "MARKET"
                }
                
                response = requests.post(self.trade_api_url, json=trade_data, timeout=30)
                result = response.json()
                
                logger.info(f"üîÑ Trade response for {symbol} {recommendation['action']} ${recommendation['amount_usd']}: {result.get('success', False)}")
                
                return result
                
            except Exception as e:
                logger.error(f"‚ùå Trade execution failed for recommendation {recommendation['id']}: {e}")
                return {"success": False, "error": str(e)}
        
        def update_recommendation_status(self, recommendation_id, status, execution_notes=None):
            """Update the status of a trade recommendation"""
            try:
                conn = mysql.connector.connect(**self.db_config)
                cursor = conn.cursor()
                
                if execution_notes:
                    query = """
                    UPDATE trade_recommendations 
                    SET status = %s, execution_notes = %s, updated_at = NOW()
                    WHERE id = %s
                    """
                    cursor.execute(query, (status, execution_notes, recommendation_id))
                else:
                    query = """
                    UPDATE trade_recommendations 
                    SET status = %s, updated_at = NOW()
                    WHERE id = %s
                    """
                    cursor.execute(query, (status, recommendation_id))
                
                conn.commit()
                cursor.close()
                conn.close()
                
            except Exception as e:
                logger.error(f"‚ùå Error updating recommendation status: {e}")
        
        def process_recommendations(self):
            """Main processing loop for trade recommendations"""
            recommendations = self.get_fresh_recommendations()
            
            if not recommendations:
                logger.info("üì≠ No fresh recommendations to process")
                return 0
            
            trades_executed = 0
            
            for rec in recommendations:
                logger.info(f"üéØ Processing: {rec['symbol']} {rec['action']} ${rec['amount_usd']} (ID: {rec['id']})")
                
                # Execute the trade
                result = self.execute_trade(rec)
                
                if result.get('success'):
                    logger.info(f"‚úÖ Trade executed successfully: {rec['symbol']} {rec['action']}")
                    self.update_recommendation_status(rec['id'], 'executed', 'Trade executed successfully')
                    trades_executed += 1
                else:
                    error_msg = result.get('message', result.get('error', 'Unknown error'))
                    logger.warning(f"‚ùå Trade failed: {rec['symbol']} - {error_msg}")
                    self.update_recommendation_status(rec['id'], 'failed', f"Trade failed: {error_msg}")
                
                # Small delay between trades
                time.sleep(1)
            
            return trades_executed
        
        def run_continuous(self):
            """Run the orchestrator in continuous mode"""
            logger.info(f"üöÄ Starting Configurable Trade Orchestrator")
            logger.info(f"   Max Age: {self.max_age_minutes} minutes")
            logger.info(f"   Max Trades/Cycle: {self.max_trades_per_cycle}")
            logger.info(f"   Check Interval: {self.check_interval} seconds")
            
            while True:
                try:
                    trades_executed = self.process_recommendations()
                    logger.info(f"üíπ Cycle complete: {trades_executed} trades executed")
                    
                    time.sleep(self.check_interval)
                    
                except KeyboardInterrupt:
                    logger.info("üõë Shutting down orchestrator...")
                    break
                except Exception as e:
                    logger.error(f"‚ùå Unexpected error in main loop: {e}")
                    time.sleep(self.check_interval)
        
        def run_test_cycle(self):
            """Run a single test cycle"""
            logger.info("üß™ Running single test cycle...")
            trades_executed = self.process_recommendations()
            logger.info(f"‚ú® Test complete: {trades_executed} trades executed")
            return trades_executed
    
    def main():
        parser = argparse.ArgumentParser(description='Simple Trade Orchestrator - Configurable Time Limits')
        parser.add_argument('--max-age-minutes', type=int, help='Maximum age of recommendations to execute (minutes). Default: 15')
        parser.add_argument('--max-trades-per-cycle', type=int, help='Maximum trades to execute per cycle. Default: 3')
        parser.add_argument('--check-interval', type=int, help='Check interval in seconds. Default: 30')
        parser.add_argument('--test', action='store_true', help='Run a single test cycle instead of continuous monitoring')
        
        args = parser.parse_args()
        
        # Create orchestrator with configuration
        orchestrator = SimpleTradeOrchestrator(
            max_age_minutes=args.max_age_minutes,
            max_trades_per_cycle=args.max_trades_per_cycle,
            check_interval=args.check_interval
        )
        
        if args.test:
            orchestrator.run_test_cycle()
        else:
            orchestrator.run_continuous()
    
    if __name__ == "__main__":
        main()
---
apiVersion: v1
kind: Service
metadata:
  name: configurable-trade-orchestrator
  namespace: crypto-trading
  labels:
    app: configurable-trade-orchestrator
spec:
  selector:
    app: configurable-trade-orchestrator
  ports:
  - name: health
    port: 8025
    targetPort: 8025
  type: ClusterIP

apiVersion: apps/v1
kind: Deployment
metadata:
  name: ollama-server
  namespace: crypto-trading
  labels:
    app: ollama-server
    component: llm-server
    node-type: analytics
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ollama-server
  template:
    metadata:
      labels:
        app: ollama-server
        component: llm-server
        node-type: analytics
    spec:
      nodeSelector:
        node-name: cryptoai-risk-analytics
      tolerations:
      - key: analytics-infrastructure
        operator: Equal
        value: "true"
        effect: NoSchedule
      containers:
      - name: ollama-server
        image: ollama/ollama:latest
        ports:
        - containerPort: 11434
          name: http
        env:
        - name: OLLAMA_HOST
          value: "0.0.0.0"
        - name: OLLAMA_ORIGINS
          value: "*"
        resources:
          limits:
            cpu: "2"
            memory: 4Gi
          requests:
            cpu: "1"
            memory: 2Gi
        volumeMounts:
        - name: ollama-data
          mountPath: /root/.ollama
        livenessProbe:
          httpGet:
            path: /api/tags
            port: 11434
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /api/tags
            port: 11434
          initialDelaySeconds: 30
          periodSeconds: 10
      volumes:
      - name: ollama-data
        emptyDir: {}

---
apiVersion: v1
kind: Service
metadata:
  name: ollama-server
  namespace: crypto-trading
  labels:
    app: ollama-server
    component: llm-server
spec:
  selector:
    app: ollama-server
  ports:
  - port: 11434
    targetPort: 11434
    protocol: TCP
  type: ClusterIP

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ollama-llm-validation
  namespace: crypto-trading
  labels:
    app: ollama-llm-validation
    component: llm-validation
    node-type: analytics
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ollama-llm-validation
  template:
    metadata:
      labels:
        app: ollama-llm-validation
        component: llm-validation
        node-type: analytics
    spec:
      nodeSelector:
        node-name: cryptoai-risk-analytics
      tolerations:
      - key: analytics-infrastructure
        operator: Equal
        value: "true"
        effect: NoSchedule
      containers:
      - name: ollama-llm-validation
        image: python:3.11-slim
        ports:
        - containerPort: 8050
          name: http
        command: ["/bin/bash", "-c"]
        args:
        - |
          pip install fastapi uvicorn requests mysql-connector-python prometheus_client
          python -c "
          import os
          import time
          import json
          import mysql.connector
          import requests
          from datetime import datetime, timedelta
          from fastapi import FastAPI, HTTPException
          import uvicorn
          import logging
          from prometheus_client import Counter, Histogram, Gauge, generate_latest
          from typing import Dict, List, Optional
          
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
          logger = logging.getLogger(__name__)
          
          # Prometheus metrics
          validations_processed = Counter('llm_validations_processed_total', 'Total LLM validations processed', ['symbol', 'signal_type'])
          validation_confidence = Histogram('llm_validation_confidence', 'LLM validation confidence scores', buckets=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])
          validation_time = Histogram('llm_validation_time_seconds', 'LLM validation processing time')
          ollama_connection_status = Gauge('ollama_connection_status', 'Ollama server connection status (1=connected, 0=disconnected)')
          
          app = FastAPI(title='LLM Validation Service')
          
          def get_db_connection():
              try:
                  return mysql.connector.connect(
                      host=os.getenv('DB_HOST'),
                      user=os.getenv('DB_USER'),
                      password=os.getenv('DB_PASSWORD'),
                      database=os.getenv('DB_NAME_PRICES')
                  )
              except Exception as e:
                  logger.error(f'Database connection error: {e}')
                  return None
          
          def get_ollama_connection():
              try:
                  response = requests.get('http://ollama-server:11434/api/tags', timeout=5)
                  return response.status_code == 200
              except Exception as e:
                  logger.error(f'Ollama connection error: {e}')
                  return False
          
          def get_recent_trades(symbol, hours=24):
              """Get recent trades for a symbol to check for duplicates and patterns"""
              try:
                  conn = get_db_connection()
                  if not conn:
                      return []
                  
                  cursor = conn.cursor()
                  cursor.execute('''
                      SELECT symbol, signal_type, amount_usd, confidence, created_at, execution_status
                      FROM trade_recommendations 
                      WHERE symbol = %s 
                      AND created_at >= DATE_SUB(NOW(), INTERVAL %s HOUR)
                      ORDER BY created_at DESC
                  ''', (symbol, hours))
                  
                  trades = cursor.fetchall()
                  cursor.close()
                  conn.close()
                  
                  return [{
                      'symbol': t[0],
                      'signal_type': t[1], 
                      'amount_usd': t[2],
                      'confidence': t[3],
                      'created_at': t[4],
                      'execution_status': t[5]
                  } for t in trades]
                  
              except Exception as e:
                  logger.error(f'Error getting recent trades: {e}')
                  return []
          
          def detect_rapid_flip_pattern(recent_trades, current_signal_type):
              """Detect if we're rapidly flipping between buy/sell for same symbol"""
              if len(recent_trades) < 2:
                  return False
              
              # Check last 3 trades for rapid flipping
              last_3_trades = recent_trades[:3]
              signal_types = [t['signal_type'] for t in last_3_trades]
              
              # If we have alternating BUY/SELL patterns, flag as suspicious
              if len(signal_types) >= 2:
                  if signal_types[0] != signal_types[1] and signal_types[0] == current_signal_type:
                      return True
              
              return False
          
          def get_last_trade_time(symbol, signal_type):
              """Get the time of the last trade for this symbol and signal type"""
              try:
                  conn = get_db_connection()
                  if not conn:
                      return None
                  
                  cursor = conn.cursor()
                  cursor.execute('''
                      SELECT created_at FROM trade_recommendations 
                      WHERE symbol = %s AND signal_type = %s 
                      AND (execution_status = %s OR execution_status = %s)
                      ORDER BY created_at DESC LIMIT 1
                  ''', (symbol, signal_type, 'EXECUTED', 'PENDING'))
                  
                  result = cursor.fetchone()
                  cursor.close()
                  conn.close()
                  
                  return result[0] if result else None
                  
              except Exception as e:
                  logger.error(f'Error getting last trade time: {e}')
                  return None
          
          def call_ollama_llm(trade_context):
              """Call actual Ollama LLM for intelligent trade validation"""
              try:
                  prompt = f"""
                  Analyze this cryptocurrency trade recommendation:
                  
                  Symbol: {trade_context['symbol']}
                  Action: {trade_context['signal_type']}
                  Confidence: {trade_context['confidence']}
                  
                  Recent 24h trade history:
                  {format_trade_history(trade_context['recent_trades'])}
                  
                  Market context:
                  {trade_context.get('market_context', 'No additional context available')}
                  
                  Should we execute this trade? Consider:
                  1. Is this a duplicate or redundant trade?
                  2. Does the trade make sense given recent activity?
                  3. Are we buying after just selling (or vice versa)?
                  4. What's the profit potential vs. risk?
                  
                  Respond with: APPROVE or REJECT and brief reasoning.
                  """
                  
                  response = requests.post('http://ollama-server:11434/api/generate', 
                      json={
                          'model': 'llama3.2:3b', 
                          'prompt': prompt,
                          'stream': False
                      },
                      timeout=30)
                  
                  if response.status_code == 200:
                      result = response.json()
                      llm_response = result.get('response', '').strip()
                      
                      # Parse LLM response
                      if 'APPROVE' in llm_response.upper():
                          return {
                              'validated': True,
                              'confidence': trade_context['confidence'] * 0.9,
                              'reasoning': f'LLM approved: {llm_response}',
                              'risk_assessment': 'low'
                          }
                      else:
                          return {
                              'validated': False,
                              'confidence': trade_context['confidence'] * 0.6,
                              'reasoning': f'LLM rejected: {llm_response}',
                              'risk_assessment': 'high'
                          }
                  else:
                      logger.warning(f'Ollama API error: {response.status_code}')
                      return None
                      
              except Exception as e:
                  logger.error(f'Error calling Ollama LLM: {e}')
                  return None
          
          def format_trade_history(trades):
              """Format trade history for LLM prompt"""
              if not trades:
                  return "No recent trades"
              
              formatted = []
              for trade in trades[:5]:  # Show last 5 trades
                  formatted.append(f"- {trade['created_at']}: {trade['signal_type']} {trade['symbol']} ${trade['amount_usd']} (confidence: {trade['confidence']:.2f})")
              
              return "\\n".join(formatted)
          
          def validate_trade_with_llm(recommendation):
              try:
                  symbol = recommendation['symbol']
                  signal_type = recommendation['signal_type']
                  confidence = recommendation['confidence']
                  
                  # 1. Check recent trade history
                  recent_trades = get_recent_trades(symbol, hours=24)
                  
                  # 2. Cooldown enforcement (1 hour minimum)
                  last_trade_time = get_last_trade_time(symbol, signal_type)
                  if last_trade_time:
                      time_diff = datetime.now() - last_trade_time
                      if time_diff.total_seconds() < 3600:  # 1 hour
                          minutes_ago = int(time_diff.total_seconds() / 60)
                          return {
                              'validated': False,
                              'confidence': confidence * 0.3,
                              'reasoning': f'Cooldown period - last {signal_type} trade was {minutes_ago} minutes ago',
                              'risk_assessment': 'high'
                          }
                  
                  # 3. Pattern detection
                  if detect_rapid_flip_pattern(recent_trades, signal_type):
                      return {
                          'validated': False,
                          'confidence': confidence * 0.2,
                          'reasoning': 'Suspicious rapid buy-sell pattern detected - avoiding flip trading',
                          'risk_assessment': 'high'
                          }
                  
                  # 4. Check for too many recent trades (max 4 per day per symbol)
                  if len(recent_trades) >= 4:
                      return {
                          'validated': False,
                          'confidence': confidence * 0.4,
                          'reasoning': f'Too many recent trades ({len(recent_trades)}) for {symbol} - daily limit reached',
                          'risk_assessment': 'high'
                      }
                  
                  # 5. Call actual Ollama LLM if available
                  if get_ollama_connection():
                      trade_context = {
                          'symbol': symbol,
                          'signal_type': signal_type,
                          'confidence': confidence,
                          'recent_trades': recent_trades,
                          'market_context': f'Current confidence: {confidence:.2f}'
                      }
                      
                      llm_result = call_ollama_llm(trade_context)
                      if llm_result:
                          return llm_result
                  
                  # 6. Fallback to enhanced rule-based validation
                  if confidence > 0.8 and len(recent_trades) < 2:
                      return {
                          'validated': True,
                          'confidence': confidence * 0.9,
                          'reasoning': f'High confidence {signal_type} signal for {symbol} - no recent conflicts',
                          'risk_assessment': 'low'
                      }
                  elif confidence > 0.7 and len(recent_trades) < 3:
                      return {
                          'validated': True,
                          'confidence': confidence * 0.8,
                          'reasoning': f'Good confidence {signal_type} signal for {symbol} - limited recent activity',
                          'risk_assessment': 'medium'
                      }
                  else:
                      return {
                          'validated': False,
                          'confidence': confidence * 0.6,
                          'reasoning': f'Insufficient confidence or too much recent activity for {signal_type} {symbol}',
                          'risk_assessment': 'high'
                      }
                  
              except Exception as e:
                  logger.error(f'LLM validation error: {e}')
                  return {
                      'validated': False,
                      'confidence': 0.3,
                      'reasoning': f'LLM validation failed: {str(e)}',
                      'risk_assessment': 'high'
                  }
          
          def process_pending_recommendations():
              try:
                  conn = get_db_connection()
                  if not conn:
                      return
                  
                  cursor = conn.cursor()
                  
                  # Get pending recommendations that need LLM validation
                  cursor.execute('''
                      SELECT id, symbol, signal_type, amount_usd, confidence, reasoning
                      FROM trade_recommendations 
                      WHERE execution_status = 'PENDING'
                      AND llm_validation IS NULL
                      AND created_at >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
                      ORDER BY created_at ASC
                      LIMIT 5
                  ''')
                  
                  recommendations = cursor.fetchall()
                  
                  for rec in recommendations:
                      recommendation = {
                          'id': rec[0],
                          'symbol': rec[1],
                          'signal_type': rec[2],
                          'amount_usd': rec[3],
                          'confidence': rec[4],
                          'reasoning': rec[5]
                      }
                      
                      # Validate with LLM
                      validation_result = validate_trade_with_llm(recommendation)
                      
                      # Update recommendation with LLM validation
                      cursor.execute('''
                          UPDATE trade_recommendations 
                          SET llm_validation = %s,
                              llm_confidence = %s,
                              llm_reasoning = %s,
                              risk_assessment = %s,
                              validation_timestamp = NOW()
                          WHERE id = %s
                      ''', (
                          validation_result['validated'],
                          validation_result['confidence'],
                          validation_result['reasoning'],
                          validation_result['risk_assessment'],
                          recommendation['id']
                      ))
                      
                      logger.info(f'LLM validation completed for recommendation {rec[0]}: {validation_result}')
                      
                      # Update metrics
                      validations_processed.labels(
                          symbol=recommendation['symbol'],
                          signal_type=recommendation['signal_type']
                      ).inc()
                      validation_confidence.observe(validation_result['confidence'])
                  
                  conn.commit()
                  cursor.close()
                  conn.close()
                  
              except Exception as e:
                  logger.error(f'Error processing recommendations: {e}')
          
          def validation_loop():
              while True:
                  try:
                      logger.info('Running LLM validation cycle...')
                      process_pending_recommendations()
                      time.sleep(30)  # Run every 30 seconds
                  except Exception as e:
                      logger.error(f'Error in validation loop: {e}')
                      time.sleep(60)
          
          @app.get('/health')
          async def health_check():
              ollama_status = get_ollama_connection()
              ollama_connection_status.set(1 if ollama_status else 0)
              return {
                  'status': 'healthy',
                  'service': 'ollama-llm-validation',
                  'ollama_connected': ollama_status
              }
          
          @app.get('/metrics')
          async def metrics():
              return Response(content=generate_latest(), media_type='text/plain')
          
          @app.post('/validate-recommendation')
          async def validate_recommendation_endpoint(recommendation: dict):
              try:
                  validation_result = validate_trade_with_llm(recommendation)
                  return {'success': True, 'validation': validation_result}
              except Exception as e:
                  raise HTTPException(status_code=500, detail=str(e))
          
          if __name__ == '__main__':
              logger.info('ðŸš€ Starting LLM Validation Service')
              
              # Start validation loop in background
              import threading
              validation_thread = threading.Thread(target=validation_loop, daemon=True)
              validation_thread.start()
              
              logger.info('âœ… LLM validation service ready')
              uvicorn.run(app, host='0.0.0.0', port=8050)
          "
        envFrom:
        - configMapRef:
            name: crypto-trading-config
        - configMapRef:
            name: database-config
        - secretRef:
            name: database-secrets
        resources:
          limits:
            cpu: 500m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 256Mi

---
apiVersion: v1
kind: Service
metadata:
  name: ollama-llm-validation
  namespace: crypto-trading
  labels:
    app: ollama-llm-validation
    component: llm-validation
spec:
  selector:
    app: ollama-llm-validation
  ports:
  - port: 8050
    targetPort: 8050
    protocol: TCP
  type: ClusterIP

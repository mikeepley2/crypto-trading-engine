# =============================================================================
# SIMPLE SIGNAL GENERATOR - Fallback without ML model
# =============================================================================

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: signal-generator-simple
  namespace: crypto-trading
  labels:
    app: signal-generator-simple
    component: signal-generation
spec:
  replicas: 1
  selector:
    matchLabels:
      app: signal-generator-simple
  template:
    metadata:
      labels:
        app: signal-generator-simple
        component: signal-generation
    spec:
      containers:
      - name: signal-generator-simple
        image: python:3.11-slim
        imagePullPolicy: Never
        ports:
        - containerPort: 8025
          name: http
        command: ["/bin/bash"]
        args:
        - -c
        - |
          # Install dependencies
          pip install fastapi uvicorn mysql-connector-python requests numpy pandas
          
          # Start the simple signal generator
          python -c "
          import os
          import logging
          import time
          import json
          import requests
          import numpy as np
          import pandas as pd
          import mysql.connector
          from datetime import datetime, timedelta
          from fastapi import FastAPI, HTTPException
          import uvicorn
          import threading
          from decimal import Decimal
          
          # Configure logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.StreamHandler()
              ]
          )
          logger = logging.getLogger(__name__)
          
          # FastAPI app for health endpoint
          app = FastAPI(title='Simple Signal Generator')
          
          # --- Database Functions ---
          def get_db_connection():
              try:
                  db_config = {
                      'host': os.getenv('DB_HOST', '172.22.32.1'),
                      'user': os.getenv('DB_USER', 'news_collector'),
                      'password': os.getenv('DB_PASSWORD'),
                      'database': os.getenv('DB_NAME_PRICES', 'crypto_prices')
                  }
                  return mysql.connector.connect(**db_config)
              except Exception as e:
                  logger.error(f'Database connection failed: {e}')
                  return None
          
          # --- Simple Signal Generation Logic ---
          def generate_simple_signal(symbol, price_data):
              '''Generate signals based on simple technical analysis'''
              try:
                  if len(price_data) < 2:
                      return None
                  
                  # Simple moving average crossover
                  current_price = price_data[-1]
                  avg_price = np.mean(price_data[-5:]) if len(price_data) >= 5 else np.mean(price_data)
                  
                  # Price momentum
                  price_change = (current_price - avg_price) / avg_price if avg_price > 0 else 0
                  
                  # Generate signal based on simple rules
                  if price_change > 0.02:  # 2% increase
                      signal_type = 'BUY'
                      confidence = min(0.8, 0.5 + abs(price_change) * 10)
                  elif price_change < -0.02:  # 2% decrease
                      signal_type = 'SELL'
                      confidence = min(0.8, 0.5 + abs(price_change) * 10)
                  else:
                      signal_type = 'HOLD'
                      confidence = 0.5
                  
                  return {
                      'symbol': symbol,
                      'signal_type': signal_type,
                      'confidence': float(confidence),
                      'prediction': 1 if signal_type == 'BUY' else 0,
                      'model_version': 'simple_technical_analysis'
                  }
              except Exception as e:
                  logger.error(f'Error generating signal for {symbol}: {e}')
                  return None
          
          def save_signal_to_db(signal):
              conn = get_db_connection()
              if not conn:
                  return False
              
              try:
                  cursor = conn.cursor()
                  
                  # Get current price for the symbol
                  try:
                      price_query = 'SELECT current_price FROM ml_features_materialized WHERE symbol = %s ORDER BY timestamp_iso DESC LIMIT 1'
                      cursor.execute(price_query, (signal['symbol'],))
                      price_result = cursor.fetchone()
                      if price_result and price_result[0] is not None:
                          current_price = float(price_result[0])
                      else:
                          current_price = 0.0
                  except Exception as e:
                      logger.warning(f'Could not get price for {signal[\"symbol\"]}: {e}')
                      current_price = 0.0
                  
                  # Insert signal into database
                  insert_query = '''
                  INSERT INTO trading_signals (
                      timestamp, symbol, price, signal_type, model, confidence, 
                      threshold, regime, model_version, features_used, xgboost_confidence,
                      data_source, created_at, is_mock, processed, prediction
                  ) VALUES (
                      NOW(), %s, %s, %s, %s, %s, 
                      0.5, 'bull', %s, 5, %s,
                      'database', NOW(), 0, 0, %s
                  )
                  '''
                  
                  values = (
                      signal['symbol'],
                      current_price,
                      signal['signal_type'],
                      signal.get('model_version', 'simple_ta'),
                      signal['confidence'],
                      signal.get('model_version', 'simple_ta'),
                      signal['confidence'],
                      float(signal.get('prediction', 1.0))
                  )
                  
                  cursor.execute(insert_query, values)
                  conn.commit()
                  
                  signal_id = cursor.lastrowid
                  logger.info(f'Signal saved: ID {signal_id}, {signal[\"symbol\"]} {signal[\"signal_type\"]} (confidence: {signal[\"confidence\"]:.3f})')
                  
                  return True
                  
              except Exception as e:
                  logger.error(f'Error saving signal to database: {e}')
                  return False
              finally:
                  if conn:
                      conn.close()
          
          def get_active_symbols():
              conn = get_db_connection()
              if not conn:
                  return []
              
              try:
                  cursor = conn.cursor()
                  query = '''
                      SELECT DISTINCT symbol 
                      FROM ml_features_materialized 
                      WHERE timestamp_iso >= NOW() - INTERVAL 1 HOUR
                      AND current_price IS NOT NULL AND current_price > 0
                      ORDER BY timestamp_iso DESC
                      LIMIT 20
                  '''
                  cursor.execute(query)
                  results = cursor.fetchall()
                  
                  symbols = [row[0] for row in results]
                  logger.info(f'Found {len(symbols)} active symbols')
                  return symbols
              except Exception as e:
                  logger.error(f'Error getting active symbols: {e}')
                  return []
              finally:
                  if conn:
                      conn.close()
          
          def get_price_data(symbol):
              conn = get_db_connection()
              if not conn:
                  return []
              
              try:
                  cursor = conn.cursor()
                  query = '''
                      SELECT current_price 
                      FROM ml_features_materialized 
                      WHERE symbol = %s 
                      AND current_price IS NOT NULL AND current_price > 0
                      ORDER BY timestamp_iso DESC 
                      LIMIT 10
                  '''
                  cursor.execute(query, (symbol,))
                  results = cursor.fetchall()
                  
                  prices = [float(row[0]) for row in results]
                  return prices
              except Exception as e:
                  logger.error(f'Error getting price data for {symbol}: {e}')
                  return []
              finally:
                  if conn:
                      conn.close()
          
          def is_asset_supported(symbol):
              supported_assets = [
                  'BTC', 'ETH', 'ADA', 'DOGE', 'XRP', 'DOT', 'LINK', 'UNI', 'AAVE', 'SOL', 
                  'MATIC', 'AVAX', 'LTC', 'BCH', 'ATOM', 'ICP', 'FIL', 'TRX', 'ETC', 'XLM',
                  'VET', 'MKR', 'COMP', 'EOS', 'THETA', 'XTZ', 'YFI', 'SHIB', 'CRV', 'ALGO',
                  'NEAR', 'OP', 'ARB', 'FLOKI', 'BONK', 'WIF', 'PEPE', 'SUSHI', 'PENGU', 'BRETT',
                  'FARTCOIN', 'AST', 'BNB', 'CVX', 'DEXT', 'BAL', 'CTX', 'AUCTION', 'ETC', 'BICO'
              ]
              return symbol in supported_assets
          
          # --- Main Signal Generation Cycle ---
          def generate_signals_cycle():
              try:
                  logger.info('üöÄ Starting simple signal generation cycle...')
                  
                  symbols = get_active_symbols()
                  if not symbols:
                      logger.warning('‚ö†Ô∏è No active symbols found')
                      return
                  
                  signals_generated = 0
                  
                  for symbol in symbols[:10]:  # Limit to top 10 symbols
                      try:
                          if not is_asset_supported(symbol):
                              continue
                          
                          price_data = get_price_data(symbol)
                          if len(price_data) < 2:
                              continue
                          
                          signal = generate_simple_signal(symbol, price_data)
                          
                          if signal and signal['signal_type'] != 'HOLD':
                              if save_signal_to_db(signal):
                                  signals_generated += 1
                                  logger.info(f'‚úÖ Generated {signal[\"signal_type\"]} signal for {symbol} (confidence: {signal[\"confidence\"]:.3f})')
                          elif signal and signal['signal_type'] == 'HOLD':
                              logger.info(f'‚ö†Ô∏è Generated HOLD signal for {symbol} (confidence: {signal[\"confidence\"]:.3f}) - not saved')
                          
                      except Exception as e:
                          logger.error(f'‚ùå Error processing {symbol}: {e}')
                          continue
                  
                  logger.info(f'Simple signal generation cycle complete: {signals_generated} signals generated')
                  
              except Exception as e:
                  logger.error(f'Error in signal generation cycle: {e}')
          
          # --- FastAPI Endpoints ---
          @app.get('/health')
          def health_check():
              db_connected = False
              try:
                  conn = get_db_connection()
                  if conn:
                      db_connected = True
                      conn.close()
              except Exception:
                  pass
              
              return {
                  'status': 'healthy' if db_connected else 'unhealthy - database not connected',
                  'model_loaded': True,
                  'database_connected': db_connected,
                  'model_type': 'simple_technical_analysis',
                  'timestamp': datetime.now().isoformat()
              }
          
          @app.on_event('startup')
          async def startup_event():
              logger.info('Starting Simple Signal Generator...')
              
              # Start signal generation in a background thread
              logger.info('Starting signal generation worker...')
              threading.Thread(target=lambda: schedule_signals(generate_signals_cycle, 300), daemon=True).start()
              
              logger.info('Simple Signal Generator initialized successfully')
          
          def schedule_signals(func, interval):
              while True:
                  func()
                  time.sleep(interval)
          
          if __name__ == '__main__':
              uvicorn.run(app, host='0.0.0.0', port=8025)
          "
        envFrom:
        - configMapRef:
            name: trade-exec-coinbase-config
        env:
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: trade-exec-coinbase-secrets
              key: DB_PASSWORD
        resources:
          requests:
            memory: "64Mi"
            cpu: "25m"
          limits:
            memory: "128Mi"
            cpu: "100m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8025
          initialDelaySeconds: 30
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 8025
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
---
apiVersion: v1
kind: Service
metadata:
  name: signal-generator-simple
  namespace: crypto-trading
  labels:
    app: signal-generator-simple
    component: signal-generation
spec:
  selector:
    app: signal-generator-simple
  ports:
    - protocol: TCP
      port: 8025
      targetPort: 8025
  type: ClusterIP

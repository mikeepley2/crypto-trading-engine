apiVersion: apps/v1
kind: Deployment
metadata:
  name: balanced-signal-generator
  namespace: crypto-trading
  labels:
    app: balanced-signal-generator
    component: signal-generation
spec:
  replicas: 1
  selector:
    matchLabels:
      app: balanced-signal-generator
  template:
    metadata:
      labels:
        app: balanced-signal-generator
        component: signal-generation
    spec:
      containers:
      - name: balanced-signal-generator
        image: python:3.11-slim
        imagePullPolicy: Never
        ports:
        - containerPort: 8025
          name: http
        command: ["/bin/bash"]
        args:
        - -c
        - |
          # Install dependencies
          pip install fastapi uvicorn mysql-connector-python requests numpy pandas scikit-learn xgboost joblib python-multipart
          
          # Create the working signal generator with all our fixes
          cat > /app/working_signal_generator.py << 'EOF'
          #!/usr/bin/env python3
          """
          Working Signal Generator with Balanced Realistic Model
          Incorporates all fixes: float32 conversion, database connection, ML model loading
          """
          
          import os
          import logging
          import time
          import json
          import requests
          import numpy as np
          import pandas as pd
          import mysql.connector
          import joblib
          from datetime import datetime, timedelta
          from fastapi import FastAPI, HTTPException
          from pydantic import BaseModel
          from typing import Optional, Dict, Any
          from threading import Thread
          import asyncio
          
          # Configure logging
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
          logger = logging.getLogger(__name__)
          
          app = FastAPI(title="Balanced Signal Generator")
          
          # Global variables
          model = None
          health_status = {
              "status": "healthy",
              "model_loaded": False,
              "database_connected": False,
              "signals_generated_today": 0,
              "last_signal_generation": None,
              "last_error": None,
              "model_type": None,
              "model_path": None
          }
          
          def get_db_connection():
              """Get database connection using Kubernetes DNS"""
              try:
                  config = {
                      'host': os.getenv('DB_HOST', '172.22.32.1'),  # Kubernetes host
                      'user': os.getenv('DB_USER', 'news_collector'),
                      'password': os.getenv('DB_PASSWORD', '99Rules!'),
                      'database': os.getenv('DB_NAME', 'crypto_prices'),
                      'charset': 'utf8mb4'
                  }
                  conn = mysql.connector.connect(**config)
                  health_status["database_connected"] = True
                  return conn
              except Exception as e:
                  logger.error(f"Database connection error: {e}")
                  health_status["database_connected"] = False
                  health_status["last_error"] = f"Database error: {e}"
                  return None
          
          def load_model():
              """Load the balanced realistic XGBoost model"""
              global model
              
              # Try multiple model paths - prioritize the balanced realistic model
              model_paths = [
                  "/app/models/balanced_realistic_model_20251005_155755.joblib", # Mounted model from ConfigMap
                  "balanced_realistic_model_20251005_155755.joblib", # New balanced model with 73.3% accuracy and 27.5% positive class
                  "comprehensive_full_dataset_model_20251005_113714.joblib", # Previous comprehensive model
                  "fast_hypertuned_model_full_dataset.joblib", # Previous hypertuned model
                  "retrained_model_with_available_features.joblib", # Previous retrained model
                  "/app/full_dataset_gpu_xgboost_model_20250827_130225.joblib",
                  "optimal_66_percent_xgboost_actual.joblib",
                  "real_model.joblib",
                  "working_model.joblib"
              ]
              
              for model_path in model_paths:
                  if os.path.exists(model_path):
                      try:
                          logger.info(f"Loading ML model from {model_path}...")
                          model = joblib.load(model_path)
                          
                          # Validate model is functional
                          if hasattr(model, 'predict') and hasattr(model, 'predict_proba'):
                              # Test model with dummy data
                              try:
                                  dummy_features = np.random.random((1, 51))  # 51 features for comprehensive model
                                  test_prediction = model.predict_proba(dummy_features)
                                  if test_prediction is not None and len(test_prediction) > 0:
                                      health_status["model_loaded"] = True
                                      health_status["model_type"] = str(type(model))
                                      health_status["model_path"] = model_path
                                      logger.info(f"ML model loaded and validated successfully from {model_path}")
                                      return True
                              except Exception as test_error:
                                  logger.warning(f"Model test failed for {model_path}: {test_error}")
                                  continue
                                      
                      except Exception as e:
                          logger.warning(f"Failed to load model from {model_path}: {e}")
                          continue
              
              health_status["model_loaded"] = False
              logger.error("No functional ML model could be loaded.")
              return False
          
          def get_latest_features(symbol):
              """Get the latest features for a symbol from ml_features_materialized"""
              conn = get_db_connection()
              if not conn:
                  return None
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  
                  # Get the latest features for the symbol
                  query = """
                  SELECT * FROM ml_features_materialized 
                  WHERE symbol = %s 
                  ORDER BY timestamp_iso DESC 
                  LIMIT 1
                  """
                  cursor.execute(query, (symbol,))
                  result = cursor.fetchone()
                  
                  if result:
                      # Exclude metadata columns
                      excluded_columns = {
                          'id', 'symbol', 'timestamp', 'price', 'price_date', 'price_hour', 
                          'timestamp_iso', 'created_at', 'updated_at'
                      }
                      feature_columns = [col for col in result.keys() if col not in excluded_columns]
                      
                      # Extract features in the same order as the comprehensive model
                      features = []
                      for col in feature_columns:
                          value = result[col]
                          if value is not None:
                              try:
                                  features.append(float(value))
                              except (ValueError, TypeError):
                                  features.append(0.0)
                          else:
                              features.append(0.0)
                      
                      # Ensure we have exactly 51 features (pad or truncate if needed)
                      if len(features) > 51:
                          features = features[:51]  # Take first 51 features
                      elif len(features) < 51:
                          features.extend([0.0] * (51 - len(features)))  # Pad with zeros
                      
                      logger.info(f"{symbol} features: {len(features)} processed for comprehensive model")
                      
                      return np.array(features).reshape(1, -1)
                  
                  return None
                  
              except Exception as e:
                  logger.error(f"Error getting features for {symbol}: {e}")
                  return None
              finally:
                  if conn:
                      conn.close()
          
          def generate_signal(symbol, features):
              """Generate a trading signal for a symbol"""
              global model
              
              if model is None:
                  return None
              
              try:
                  # Fallback mode for when ML model is not available
                  if model == "fallback":
                      if symbol in ['BTC', 'ETH']:
                          signal_type = "BUY"
                          confidence = 0.65
                          prediction = 1
                      else:
                          signal_type = "HOLD"
                          confidence = 0.5
                          prediction = 0
                      
                      return {
                          'symbol': symbol,
                          'signal_type': signal_type,
                          'confidence': float(confidence),  # Convert to Python float
                          'prediction': int(prediction),    # Convert to Python int
                          'model_version': 'fallback_mode'
                      }
                  
                  # ML model prediction
                  if not hasattr(model, 'predict') or not hasattr(model, 'predict_proba'):
                      logger.error(f"ML model is not functional for {symbol}")
                      return None
                  
                  try:
                      prediction = model.predict(features)[0]
                      probabilities = model.predict_proba(features)[0]
                      confidence = max(probabilities)
                      
                      # Convert prediction to signal with optimized thresholds for balanced model
                      if prediction == 1 and confidence > 0.5:  # Buy signal with moderate confidence (27.5% positive class)
                          signal_type = "BUY"
                      elif prediction == 0 and confidence > 0.6:  # Strong HOLD signal
                          signal_type = "HOLD"
                      else:
                          signal_type = "HOLD"  # Default to HOLD for low confidence
                      
                      return {
                          'symbol': symbol,
                          'signal_type': signal_type,
                          'confidence': float(confidence),  # Convert numpy float32 to Python float
                          'prediction': int(prediction),    # Convert numpy int to Python int
                          'model_version': 'xgboost_ml_model'
                      }
                  except Exception as ml_error:
                      logger.error(f"ML model prediction failed for {symbol}: {ml_error}")
                      return None
                  
              except Exception as e:
                  logger.error(f"Error generating signal for {symbol}: {e}")
                  return None
          
          def save_signal_to_db(signal):
              """Save signal to database"""
              conn = get_db_connection()
              if not conn:
                  return False
              
              try:
                  cursor = conn.cursor()
                  
                  # Insert signal into database
                  insert_query = """
                  INSERT INTO trading_signals (
                      symbol, signal_type, confidence, prediction, 
                      model_version, timestamp, created_at
                  ) VALUES (%s, %s, %s, %s, %s, %s, %s)
                  """
                  
                  values = (
                      signal['symbol'],
                      signal['signal_type'],
                      signal['confidence'],
                      signal['prediction'],
                      signal['model_version'],
                      datetime.now(),
                      datetime.now()
                  )
                  
                  cursor.execute(insert_query, values)
                  conn.commit()
                  
                  signal_id = cursor.lastrowid
                  logger.info(f"Signal saved to DB: ID {signal_id}, {signal['symbol']} {signal['signal_type']} (confidence: {signal['confidence']:.3f})")
                  
                  return True
                  
              except Exception as e:
                  logger.error(f"Error saving signal to database: {e}")
                  return False
              finally:
                  if conn:
                      conn.close()
          
          def get_active_symbols():
              """Get list of active trading symbols"""
              conn = get_db_connection()
              if not conn:
                  return ['BTC', 'ETH', 'ADA', 'SOL', 'DOT']  # Fallback symbols
              
              try:
                  cursor = conn.cursor()
                  query = """
                  SELECT DISTINCT symbol 
                  FROM ml_features_materialized 
                  WHERE timestamp_iso >= %s
                  ORDER BY symbol
                  """
                  
                  # Get symbols with data from last 24 hours
                  cutoff_time = datetime.now() - timedelta(hours=24)
                  cursor.execute(query, (cutoff_time,))
                  
                  symbols = [row[0] for row in cursor.fetchall()]
                  
                  if not symbols:
                      return ['BTC', 'ETH', 'ADA', 'SOL', 'DOT']  # Fallback
                  
                  logger.info(f"Found {len(symbols)} active symbols")
                  return symbols
                  
              except Exception as e:
                  logger.error(f"Error getting active symbols: {e}")
                  return ['BTC', 'ETH', 'ADA', 'SOL', 'DOT']  # Fallback
              finally:
                  if conn:
                      conn.close()
          
          def generate_signals_cycle():
              """Generate signals for all active symbols"""
              try:
                  symbols = get_active_symbols()
                  signals_generated = 0
                  
                  logger.info(f"Starting signal generation cycle for {len(symbols)} symbols...")
                  
                  for symbol in symbols:
                      try:
                          # Get features for symbol
                          features = get_latest_features(symbol)
                          if features is None:
                              logger.warning(f"No features available for {symbol}")
                              continue
                          
                          # Generate signal
                          signal = generate_signal(symbol, features)
                          if signal is None:
                              logger.warning(f"Could not generate signal for {symbol}")
                              continue
                          
                          # Only save BUY signals (HOLD signals are not saved to reduce noise)
                          if signal['signal_type'] == 'BUY':
                              if save_signal_to_db(signal):
                                  signals_generated += 1
                                  logger.info(f"Generated BUY signal for {symbol} (confidence: {signal['confidence']:.3f})")
                          else:
                              logger.debug(f"Generated HOLD signal for {symbol} (confidence: {signal['confidence']:.3f}) - not saved")
                          
                      except Exception as e:
                          logger.error(f"Error processing {symbol}: {e}")
                          continue
                  
                  health_status["signals_generated_today"] += signals_generated
                  health_status["last_signal_generation"] = datetime.now().isoformat()
                  
                  logger.info(f"Signal generation cycle complete: {signals_generated} signals generated")
                  return signals_generated
                  
              except Exception as e:
                  logger.error(f"Error in signal generation cycle: {e}")
                  health_status["last_error"] = f"Signal generation error: {e}"
                  return 0
          
          def signal_generation_worker():
              """Background worker for signal generation"""
              while True:
                  try:
                      generate_signals_cycle()
                      time.sleep(300)  # Wait 5 minutes between cycles
                  except Exception as e:
                      logger.error(f"Error in signal generation worker: {e}")
                      time.sleep(60)  # Wait 1 minute on error
          
          # FastAPI endpoints
          @app.get("/")
          async def read_root():
              return {
                  "message": "Balanced Signal Generator is running",
                  "endpoints": {
                      "health": "/health",
                      "status": "/status",
                      "generate_signals": "POST /generate_signals"
                  }
              }
          
          @app.get("/health")
          async def health_check():
              return {
                  "status": health_status["status"],
                  "service": "balanced-signal-generator",
                  "timestamp": datetime.now().isoformat(),
                  "model_loaded": health_status["model_loaded"],
                  "database_connected": health_status["database_connected"],
                  "signals_generated_today": health_status["signals_generated_today"]
              }
          
          @app.get("/status")
          async def get_status():
              return health_status
          
          @app.post("/generate_signals")
          async def generate_signals_endpoint():
              """Manually trigger signal generation"""
              try:
                  signals_generated = generate_signals_cycle()
                  return {
                      "status": "success",
                      "signals_generated": signals_generated,
                      "message": f"Generated {signals_generated} signals"
                  }
              except Exception as e:
                  logger.error(f"Error in generate_signals endpoint: {e}")
                  raise HTTPException(status_code=500, detail=str(e))
          
          @app.on_event("startup")
          async def startup_event():
              logger.info("Starting Balanced Signal Generator...")
              
              # Load ML model
              if load_model():
                  logger.info("Model loaded successfully")
              else:
                  logger.error("Failed to load model")
              
              # Test database connection
              conn = get_db_connection()
              if conn:
                  logger.info("Database connection successful")
                  conn.close()
              else:
                  logger.error("Database connection failed")
              
              # Start signal generation worker
              logger.info("Starting signal generation worker...")
              worker_thread = Thread(target=signal_generation_worker, daemon=True)
              worker_thread.start()
              
              logger.info("Balanced Signal Generator initialized successfully")
          
          if __name__ == "__main__":
              port = int(os.getenv('PORT', 8025))
              logger.info(f"Service will be available at http://0.0.0.0:{port}")
              uvicorn.run(app, host="0.0.0.0", port=port)
          EOF
          
          # Copy the balanced model to the container
          # Note: In production, this would be mounted as a volume or downloaded from a model registry
          # For now, we'll create a placeholder that will use fallback mode
          echo "Creating model placeholder..."
          
          # Start the service
          python /app/working_signal_generator.py
        env:
        - name: DB_HOST
          value: "172.22.32.1"  # Kubernetes host IP
        - name: DB_USER
          value: "news_collector"
        - name: DB_PASSWORD
          value: "99Rules!"
        - name: DB_NAME
          value: "crypto_prices"
        - name: PORT
          value: "8025"
        volumeMounts:
        - name: model-volume
          mountPath: /app/models
          readOnly: true
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8025
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8025
          initialDelaySeconds: 30
          periodSeconds: 10
      volumes:
      - name: model-volume
        configMap:
          name: balanced-model-file
---
apiVersion: v1
kind: Service
metadata:
  name: balanced-signal-generator
  namespace: crypto-trading
  labels:
    app: balanced-signal-generator
    component: signal-generation
spec:
  selector:
    app: balanced-signal-generator
  ports:
  - port: 8025
    targetPort: 8025
    protocol: TCP
    name: http
  type: ClusterIP

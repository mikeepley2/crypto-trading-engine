# =============================================================================
# OLLAMA LLM VALIDATION SERVICE - Fixed Version
# =============================================================================

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: ollama-config
  namespace: crypto-trading
data:
  OLLAMA_HOST: "0.0.0.0"
  OLLAMA_PORT: "11434"
  OLLAMA_DEFAULT_MODEL: "llama2:7b"
  SERVICE_PORT: "8050"
  OLLAMA_URL: "http://ollama:11434"

---
# Ollama Core Service - LLM Runtime
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ollama
  namespace: crypto-trading
  labels:
    app: ollama
    component: llm-runtime
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: ollama
  template:
    metadata:
      labels:
        app: ollama
        component: llm-runtime
    spec:
      containers:
      - name: ollama
        image: ollama/ollama:latest
        ports:
        - containerPort: 11434
          name: http
        env:
        - name: OLLAMA_HOST
          valueFrom:
            configMapKeyRef:
              name: ollama-config
              key: OLLAMA_HOST
        - name: OLLAMA_PORT
          valueFrom:
            configMapKeyRef:
              name: ollama-config
              key: OLLAMA_PORT
        volumeMounts:
        - name: ollama-models
          mountPath: /root/.ollama
        resources:
          requests:
            memory: "4Gi"
            cpu: "1000m"
          limits:
            memory: "8Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /
            port: 11434
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /api/tags
            port: 11434
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        startupProbe:
          httpGet:
            path: /
            port: 11434
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 10
      volumes:
      - name: ollama-models
        hostPath:
          path: /tmp/ollama-models
          type: DirectoryOrCreate

---
apiVersion: v1
kind: Service
metadata:
  name: ollama
  namespace: crypto-trading
  labels:
    app: ollama
spec:
  selector:
    app: ollama
  ports:
  - name: http
    port: 11434
    targetPort: 11434
  type: ClusterIP

---
# Ollama LLM Validation Service - Using Python file
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ollama-llm-validation
  namespace: crypto-trading
  labels:
    app: ollama-llm-validation
    component: llm-validation
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ollama-llm-validation
  template:
    metadata:
      labels:
        app: ollama-llm-validation
        component: llm-validation
    spec:
      containers:
      - name: ollama-llm-validation
        image: python:3.11-slim
        imagePullPolicy: Never
        ports:
        - containerPort: 8050
          name: http
        command: ["/bin/bash"]
        args:
        - -c
        - |
          # Install dependencies
          pip install fastapi uvicorn mysql-connector-python requests aiohttp
          
          # Copy the Python service file
          cat > /app/ollama_llm_validation_service.py << 'EOF'
          #!/usr/bin/env python3
          """
          Ollama LLM Validation Service
          Validates trade recommendations using Ollama LLM models
          """
          
          import os
          import logging
          import time
          import json
          import requests
          import aiohttp
          import asyncio
          import mysql.connector
          from datetime import datetime, timedelta
          from fastapi import FastAPI, HTTPException
          import uvicorn
          import threading
          
          # Configure logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.StreamHandler()
              ]
          )
          logger = logging.getLogger(__name__)
          
          # FastAPI app
          app = FastAPI(title='Ollama LLM Validation Service')
          
          # Configuration
          OLLAMA_URL = os.getenv('OLLAMA_URL', 'http://ollama:11434')
          DEFAULT_MODEL = os.getenv('OLLAMA_DEFAULT_MODEL', 'llama2:7b')
          
          # --- Database Functions ---
          def get_db_connection():
              try:
                  db_config = {
                      'host': os.getenv('DB_HOST', '172.22.32.1'),
                      'user': os.getenv('DB_USER', 'news_collector'),
                      'password': os.getenv('DB_PASSWORD'),
                      'database': os.getenv('DB_NAME_PRICES', 'crypto_prices')
                  }
                  return mysql.connector.connect(**db_config)
              except Exception as e:
                  logger.error(f'Database connection failed: {e}')
                  return None
          
          # --- Ollama Functions ---
          async def check_ollama_models():
              """Check available Ollama models"""
              try:
                  async with aiohttp.ClientSession() as session:
                      async with session.get(f'{OLLAMA_URL}/api/tags', timeout=10) as response:
                          if response.status == 200:
                              data = await response.json()
                              models = [model['name'] for model in data.get('models', [])]
                              logger.info(f'Available Ollama models: {models}')
                              return models
                          else:
                              logger.warning(f'Failed to get Ollama models: {response.status}')
                              return []
              except Exception as e:
                  logger.error(f'Error checking Ollama models: {e}')
                  return []
          
          def fallback_validation(recommendation, market_context):
              """Fallback validation using simple rules"""
              symbol = recommendation['symbol']
              signal_type = recommendation['signal_type']
              confidence = recommendation['confidence']
              amount = recommendation['amount_usd']
              
              # Simple validation rules
              validation_score = 0.0
              reasoning_parts = []
              
              # Confidence check
              if confidence > 0.7:
                  validation_score += 0.3
                  reasoning_parts.append('High confidence signal')
              elif confidence > 0.5:
                  validation_score += 0.2
                  reasoning_parts.append('Moderate confidence signal')
              else:
                  reasoning_parts.append('Low confidence signal')
              
              # RSI check
              rsi = market_context.get('rsi', 50)
              if signal_type == 'BUY' and rsi < 70:
                  validation_score += 0.2
                  reasoning_parts.append('RSI not overbought')
              elif signal_type == 'SELL' and rsi > 30:
                  validation_score += 0.2
                  reasoning_parts.append('RSI not oversold')
              
              # Sentiment check
              sentiment = market_context.get('sentiment', 'neutral')
              if sentiment == 'bullish' and signal_type == 'BUY':
                  validation_score += 0.2
                  reasoning_parts.append('Bullish sentiment supports buy')
              elif sentiment == 'bearish' and signal_type == 'SELL':
                  validation_score += 0.2
                  reasoning_parts.append('Bearish sentiment supports sell')
              
              # Amount check
              if amount <= 100:
                  validation_score += 0.1
                  reasoning_parts.append('Reasonable trade size')
              elif amount > 1000:
                  validation_score -= 0.2
                  reasoning_parts.append('Large trade size - high risk')
              
              # Determine validation result
              if validation_score >= 0.6:
                  validation = 'APPROVE'
              elif validation_score >= 0.3:
                  validation = 'MODIFY'
                  suggested_amount = amount * 0.5
              else:
                  validation = 'REJECT'
                  suggested_amount = 0.0
              
              # Risk assessment
              if validation_score >= 0.7:
                  risk = 'LOW'
              elif validation_score >= 0.4:
                  risk = 'MEDIUM'
              else:
                  risk = 'HIGH'
              
              return {
                  'validation': validation,
                  'confidence': min(1.0, max(0.0, validation_score)),
                  'reasoning': '; '.join(reasoning_parts),
                  'risk_assessment': risk,
                  'suggested_amount': suggested_amount if validation == 'MODIFY' else amount
              }
          
          def get_market_context(symbol):
              """Get comprehensive market context for a symbol"""
              conn = get_db_connection()
              if not conn:
                  return {}
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  
                  # Get recent price data
                  cursor.execute('''
                      SELECT current_price, volume_24h, timestamp_iso
                      FROM ml_features_materialized 
                      WHERE symbol = %s 
                      ORDER BY timestamp_iso DESC 
                      LIMIT 5
                  ''', (symbol,))
                  price_data = cursor.fetchall()
                  
                  # Get technical indicators
                  cursor.execute('''
                      SELECT rsi, crypto_sentiment, vix, sentiment_score
                      FROM ml_features_materialized 
                      WHERE symbol = %s 
                      ORDER BY timestamp_iso DESC 
                      LIMIT 1
                  ''', (symbol,))
                  indicators = cursor.fetchone()
                  
                  context = {
                      'symbol': symbol,
                      'current_price': price_data[0]['current_price'] if price_data else None,
                      'volume_24h': price_data[0]['volume_24h'] if price_data else None,
                      'price_trend': 'up' if len(price_data) > 1 and price_data[0]['current_price'] > price_data[1]['current_price'] else 'down',
                      'rsi': indicators['rsi'] if indicators else None,
                      'sentiment': indicators['crypto_sentiment'] if indicators else None,
                      'vix': indicators['vix'] if indicators else None,
                      'sentiment_score': indicators['sentiment_score'] if indicators else None
                  }
                  
                  return context
              except Exception as e:
                  logger.error(f'Error getting market context for {symbol}: {e}')
                  return {}
              finally:
                  if conn:
                      conn.close()
          
          def validate_recommendation(recommendation_id):
              """Validate a specific recommendation"""
              conn = get_db_connection()
              if not conn:
                  return None
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  
                  # Get recommendation details
                  cursor.execute('''
                      SELECT * FROM trade_recommendations 
                      WHERE id = %s
                  ''', (recommendation_id,))
                  recommendation = cursor.fetchone()
                  
                  if not recommendation:
                      return None
                  
                  # Get market context
                  market_context = get_market_context(recommendation['symbol'])
                  
                  # Use fallback validation for now (Ollama integration can be added later)
                  validation_result = fallback_validation(recommendation, market_context)
                  
                  # Update recommendation with validation results
                  cursor.execute('''
                      UPDATE trade_recommendations 
                      SET llm_validation = %s,
                          llm_confidence = %s,
                          llm_reasoning = %s,
                          risk_assessment = %s,
                          suggested_amount = %s,
                          validation_timestamp = NOW()
                      WHERE id = %s
                  ''', (
                      validation_result['validation'],
                      validation_result['confidence'],
                      validation_result['reasoning'],
                      validation_result['risk_assessment'],
                      validation_result['suggested_amount'],
                      recommendation_id
                  ))
                  
                  conn.commit()
                  
                  logger.info(f'Validated recommendation {recommendation_id}: {validation_result["validation"]} (confidence: {validation_result["confidence"]:.3f})')
                  
                  return validation_result
                  
              except Exception as e:
                  logger.error(f'Error validating recommendation {recommendation_id}: {e}')
                  return None
              finally:
                  if conn:
                      conn.close()
          
          def validate_pending_recommendations():
              """Validate all pending recommendations"""
              conn = get_db_connection()
              if not conn:
                  return
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  
                  # Get pending recommendations that haven't been validated
                  cursor.execute('''
                      SELECT id FROM trade_recommendations 
                      WHERE execution_status = 'PENDING'
                      AND (llm_validation IS NULL OR llm_validation = '')
                      AND created_at >= NOW() - INTERVAL 30 MINUTE
                      ORDER BY created_at DESC
                      LIMIT 5
                  ''')
                  
                  recommendations = cursor.fetchall()
                  
                  validated_count = 0
                  for rec in recommendations:
                      result = validate_recommendation(rec['id'])
                      if result:
                          validated_count += 1
                  
                  logger.info(f'Validated {validated_count} recommendations')
                  
              except Exception as e:
                  logger.error(f'Error in validation cycle: {e}')
              finally:
                  if conn:
                      conn.close()
          
          # --- FastAPI Endpoints ---
          @app.get('/health')
          def health_check():
              return {
                  'status': 'healthy',
                  'service': 'ollama_llm_validation',
                  'ollama_url': OLLAMA_URL,
                  'default_model': DEFAULT_MODEL,
                  'timestamp': datetime.now().isoformat()
              }
          
          @app.post('/validate/{recommendation_id}')
          async def validate_endpoint(recommendation_id: int):
              result = validate_recommendation(recommendation_id)
              if result:
                  return result
              else:
                  raise HTTPException(status_code=404, detail='Recommendation not found or validation failed')
          
          @app.get('/status')
          def get_status():
              conn = get_db_connection()
              if not conn:
                  return {'status': 'unhealthy', 'error': 'Database not connected'}
              
              try:
                  cursor = conn.cursor()
                  cursor.execute('''
                      SELECT COUNT(*) FROM trade_recommendations 
                      WHERE execution_status = 'PENDING'
                      AND (llm_validation IS NULL OR llm_validation = '')
                  ''')
                  pending_validation = cursor.fetchone()[0]
                  
                  cursor.execute('''
                      SELECT COUNT(*) FROM trade_recommendations 
                      WHERE llm_validation = 'APPROVE'
                      AND execution_status = 'PENDING'
                  ''')
                  approved_pending = cursor.fetchone()[0]
                  
                  return {
                      'status': 'healthy',
                      'pending_validation': pending_validation,
                      'approved_pending': approved_pending,
                      'ollama_url': OLLAMA_URL,
                      'timestamp': datetime.now().isoformat()
                  }
              except Exception as e:
                  return {'status': 'unhealthy', 'error': str(e)}
              finally:
                  if conn:
                      conn.close()
          
          @app.on_event('startup')
          async def startup_event():
              logger.info('Starting Ollama LLM Validation Service...')
              
              # Start validation worker
              def validation_worker():
                  while True:
                      try:
                          validate_pending_recommendations()
                          time.sleep(60)  # Validate every minute
                      except Exception as e:
                          logger.error(f'Error in validation worker: {e}')
                          time.sleep(60)
              
              threading.Thread(target=validation_worker, daemon=True).start()
              logger.info('Ollama LLM Validation Service started')
          
          if __name__ == '__main__':
              uvicorn.run(app, host='0.0.0.0', port=8050)
          EOF
          
          # Start the service
          python /app/ollama_llm_validation_service.py
        envFrom:
        - configMapRef:
            name: ollama-config
        - configMapRef:
            name: trade-exec-coinbase-config
        env:
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: trade-exec-coinbase-secrets
              key: DB_PASSWORD
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8050
          initialDelaySeconds: 30
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 8050
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3

---
apiVersion: v1
kind: Service
metadata:
  name: ollama-llm-validation
  namespace: crypto-trading
  labels:
    app: ollama-llm-validation
spec:
  selector:
    app: ollama-llm-validation
  ports:
  - name: http
    port: 8050
    targetPort: 8050
  type: ClusterIP

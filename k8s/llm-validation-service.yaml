# =============================================================================
# LLM VALIDATION SERVICE - Validates trade recommendations using LLM
# =============================================================================

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: llm-validation-service
  namespace: crypto-trading
  labels:
    app: llm-validation-service
    component: llm-validation
spec:
  replicas: 1
  selector:
    matchLabels:
      app: llm-validation-service
  template:
    metadata:
      labels:
        app: llm-validation-service
        component: llm-validation
    spec:
      containers:
      - name: llm-validation-service
        image: python:3.11-slim
        imagePullPolicy: Never
        ports:
        - containerPort: 8026
          name: http
        command: ["/bin/bash"]
        args:
        - -c
        - |
          # Install dependencies
          pip install fastapi uvicorn mysql-connector-python requests openai anthropic
          
          # Start the LLM validation service
          python -c "
          import os
          import logging
          import time
          import json
          import requests
          import mysql.connector
          from datetime import datetime, timedelta
          from fastapi import FastAPI, HTTPException
          import uvicorn
          import threading
          
          # Configure logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.StreamHandler()
              ]
          )
          logger = logging.getLogger(__name__)
          
          # FastAPI app
          app = FastAPI(title='LLM Validation Service')
          
          # --- Database Functions ---
          def get_db_connection():
              try:
                  db_config = {
                      'host': os.getenv('DB_HOST', '172.22.32.1'),
                      'user': os.getenv('DB_USER', 'news_collector'),
                      'password': os.getenv('DB_PASSWORD'),
                      'database': os.getenv('DB_NAME_PRICES', 'crypto_prices')
                  }
                  return mysql.connector.connect(**db_config)
              except Exception as e:
                  logger.error(f'Database connection failed: {e}')
                  return None
          
          # --- LLM Validation Functions ---
          def get_market_context(symbol):
              '''Get comprehensive market context for a symbol'''
              conn = get_db_connection()
              if not conn:
                  return {}
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  
                  # Get recent price data
                  cursor.execute('''
                      SELECT current_price, volume_24h, timestamp_iso
                      FROM ml_features_materialized 
                      WHERE symbol = %s 
                      ORDER BY timestamp_iso DESC 
                      LIMIT 5
                  ''', (symbol,))
                  price_data = cursor.fetchall()
                  
                  # Get technical indicators
                  cursor.execute('''
                      SELECT rsi, crypto_sentiment, vix, sentiment_score
                      FROM ml_features_materialized 
                      WHERE symbol = %s 
                      ORDER BY timestamp_iso DESC 
                      LIMIT 1
                  ''', (symbol,))
                  indicators = cursor.fetchone()
                  
                  # Get recent signals
                  cursor.execute('''
                      SELECT signal_type, confidence, timestamp
                      FROM trading_signals 
                      WHERE symbol = %s 
                      ORDER BY timestamp DESC 
                      LIMIT 3
                  ''', (symbol,))
                  recent_signals = cursor.fetchall()
                  
                  context = {
                      'symbol': symbol,
                      'current_price': price_data[0]['current_price'] if price_data else None,
                      'volume_24h': price_data[0]['volume_24h'] if price_data else None,
                      'price_trend': 'up' if len(price_data) > 1 and price_data[0]['current_price'] > price_data[1]['current_price'] else 'down',
                      'rsi': indicators['rsi'] if indicators else None,
                      'sentiment': indicators['crypto_sentiment'] if indicators else None,
                      'vix': indicators['vix'] if indicators else None,
                      'sentiment_score': indicators['sentiment_score'] if indicators else None,
                      'recent_signals': [{'type': s['signal_type'], 'confidence': s['confidence']} for s in recent_signals]
                  }
                  
                  return context
              except Exception as e:
                  logger.error(f'Error getting market context for {symbol}: {e}')
                  return {}
              finally:
                  if conn:
                      conn.close()
          
          def validate_with_llm(recommendation, market_context):
              '''Validate trade recommendation using LLM analysis'''
              try:
                  # Create prompt for LLM validation
                  prompt = f'''
                  As a cryptocurrency trading expert, analyze this trade recommendation:
                  
                  SYMBOL: {recommendation['symbol']}
                  SIGNAL TYPE: {recommendation['signal_type']}
                  CONFIDENCE: {recommendation['confidence']:.3f}
                  AMOUNT: ${recommendation['amount_usd']}
                  
                  MARKET CONTEXT:
                  - Current Price: ${market_context.get('current_price', 'N/A')}
                  - Volume 24h: {market_context.get('volume_24h', 'N/A')}
                  - Price Trend: {market_context.get('price_trend', 'N/A')}
                  - RSI: {market_context.get('rsi', 'N/A')}
                  - Market Sentiment: {market_context.get('sentiment', 'N/A')}
                  - VIX: {market_context.get('vix', 'N/A')}
                  - Sentiment Score: {market_context.get('sentiment_score', 'N/A')}
                  - Recent Signals: {market_context.get('recent_signals', [])}
                  
                  Please provide:
                  1. VALIDATION: APPROVE, REJECT, or MODIFY
                  2. CONFIDENCE: 0.0 to 1.0
                  3. REASONING: Brief explanation
                  4. RISK_ASSESSMENT: LOW, MEDIUM, or HIGH
                  5. SUGGESTED_AMOUNT: Recommended trade amount (if MODIFY)
                  
                  Respond in JSON format:
                  {{
                      \"validation\": \"APPROVE|REJECT|MODIFY\",
                      \"confidence\": 0.0-1.0,
                      \"reasoning\": \"explanation\",
                      \"risk_assessment\": \"LOW|MEDIUM|HIGH\",
                      \"suggested_amount\": 0.0
                  }}
                  '''
                  
                  # For now, use a simple rule-based validation
                  # In production, this would call OpenAI, Anthropic, or another LLM API
                  validation_result = simple_llm_validation(recommendation, market_context)
                  
                  return validation_result
              except Exception as e:
                  logger.error(f'Error in LLM validation: {e}')
                  return {
                      'validation': 'REJECT',
                      'confidence': 0.0,
                      'reasoning': f'Validation error: {e}',
                      'risk_assessment': 'HIGH',
                      'suggested_amount': 0.0
                  }
          
          def simple_llm_validation(recommendation, market_context):
              '''Simple rule-based validation (placeholder for real LLM)'''
              symbol = recommendation['symbol']
              signal_type = recommendation['signal_type']
              confidence = recommendation['confidence']
              amount = recommendation['amount_usd']
              
              # Get market data
              current_price = market_context.get('current_price', 0)
              rsi = market_context.get('rsi', 50)
              sentiment = market_context.get('sentiment', 'neutral')
              vix = market_context.get('vix', 20)
              
              # Simple validation rules
              validation_score = 0.0
              reasoning_parts = []
              
              # Confidence check
              if confidence > 0.7:
                  validation_score += 0.3
                  reasoning_parts.append('High confidence signal')
              elif confidence > 0.5:
                  validation_score += 0.2
                  reasoning_parts.append('Moderate confidence signal')
              else:
                  reasoning_parts.append('Low confidence signal')
              
              # RSI check
              if signal_type == 'BUY' and rsi < 70:
                  validation_score += 0.2
                  reasoning_parts.append('RSI not overbought')
              elif signal_type == 'SELL' and rsi > 30:
                  validation_score += 0.2
                  reasoning_parts.append('RSI not oversold')
              
              # Sentiment check
              if sentiment == 'bullish' and signal_type == 'BUY':
                  validation_score += 0.2
                  reasoning_parts.append('Bullish sentiment supports buy')
              elif sentiment == 'bearish' and signal_type == 'SELL':
                  validation_score += 0.2
                  reasoning_parts.append('Bearish sentiment supports sell')
              
              # VIX check (market volatility)
              if vix < 30:  # Low volatility
                  validation_score += 0.1
                  reasoning_parts.append('Low market volatility')
              elif vix > 50:  # High volatility
                  validation_score -= 0.1
                  reasoning_parts.append('High market volatility')
              
              # Amount check
              if amount <= 100:
                  validation_score += 0.1
                  reasoning_parts.append('Reasonable trade size')
              elif amount > 1000:
                  validation_score -= 0.2
                  reasoning_parts.append('Large trade size - high risk')
              
              # Determine validation result
              if validation_score >= 0.6:
                  validation = 'APPROVE'
              elif validation_score >= 0.3:
                  validation = 'MODIFY'
                  suggested_amount = amount * 0.5  # Reduce amount
              else:
                  validation = 'REJECT'
                  suggested_amount = 0.0
              
              # Risk assessment
              if validation_score >= 0.7:
                  risk = 'LOW'
              elif validation_score >= 0.4:
                  risk = 'MEDIUM'
              else:
                  risk = 'HIGH'
              
              return {
                  'validation': validation,
                  'confidence': min(1.0, max(0.0, validation_score)),
                  'reasoning': '; '.join(reasoning_parts),
                  'risk_assessment': risk,
                  'suggested_amount': suggested_amount if validation == 'MODIFY' else amount
              }
          
          def validate_recommendation(recommendation_id):
              '''Validate a specific recommendation'''
              conn = get_db_connection()
              if not conn:
                  return None
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  
                  # Get recommendation details
                  cursor.execute('''
                      SELECT * FROM trade_recommendations 
                      WHERE id = %s
                  ''', (recommendation_id,))
                  recommendation = cursor.fetchone()
                  
                  if not recommendation:
                      return None
                  
                  # Get market context
                  market_context = get_market_context(recommendation['symbol'])
                  
                  # Validate with LLM
                  validation_result = validate_with_llm(recommendation, market_context)
                  
                  # Update recommendation with validation results
                  cursor.execute('''
                      UPDATE trade_recommendations 
                      SET llm_validation = %s,
                          llm_confidence = %s,
                          llm_reasoning = %s,
                          risk_assessment = %s,
                          suggested_amount = %s,
                          validation_timestamp = NOW()
                      WHERE id = %s
                  ''', (
                      validation_result['validation'],
                      validation_result['confidence'],
                      validation_result['reasoning'],
                      validation_result['risk_assessment'],
                      validation_result['suggested_amount'],
                      recommendation_id
                  ))
                  
                  conn.commit()
                  
                  logger.info(f'Validated recommendation {recommendation_id}: {validation_result[\"validation\"]} (confidence: {validation_result[\"confidence\"]:.3f})')
                  
                  return validation_result
                  
              except Exception as e:
                  logger.error(f'Error validating recommendation {recommendation_id}: {e}')
                  return None
              finally:
                  if conn:
                      conn.close()
          
          def validate_pending_recommendations():
              '''Validate all pending recommendations'''
              conn = get_db_connection()
              if not conn:
                  return
              
              try:
                  cursor = conn.cursor(dictionary=True)
                  
                  # Get pending recommendations that haven't been validated
                  cursor.execute('''
                      SELECT id FROM trade_recommendations 
                      WHERE execution_status = 'PENDING'
                      AND (llm_validation IS NULL OR llm_validation = '')
                      AND created_at >= NOW() - INTERVAL 30 MINUTE
                      ORDER BY created_at DESC
                      LIMIT 10
                  ''')
                  
                  recommendations = cursor.fetchall()
                  
                  validated_count = 0
                  for rec in recommendations:
                      result = validate_recommendation(rec['id'])
                      if result:
                          validated_count += 1
                  
                  logger.info(f'Validated {validated_count} recommendations')
                  
              except Exception as e:
                  logger.error(f'Error in validation cycle: {e}')
              finally:
                  if conn:
                      conn.close()
          
          # --- FastAPI Endpoints ---
          @app.get('/health')
          def health_check():
              return {
                  'status': 'healthy',
                  'service': 'llm_validation',
                  'timestamp': datetime.now().isoformat()
              }
          
          @app.post('/validate/{recommendation_id}')
          async def validate_endpoint(recommendation_id: int):
              result = validate_recommendation(recommendation_id)
              if result:
                  return result
              else:
                  raise HTTPException(status_code=404, detail='Recommendation not found or validation failed')
          
          @app.get('/status')
          def get_status():
              conn = get_db_connection()
              if not conn:
                  return {'status': 'unhealthy', 'error': 'Database not connected'}
              
              try:
                  cursor = conn.cursor()
                  cursor.execute('''
                      SELECT COUNT(*) FROM trade_recommendations 
                      WHERE execution_status = 'PENDING'
                      AND (llm_validation IS NULL OR llm_validation = '')
                  ''')
                  pending_validation = cursor.fetchone()[0]
                  
                  cursor.execute('''
                      SELECT COUNT(*) FROM trade_recommendations 
                      WHERE llm_validation = 'APPROVE'
                      AND execution_status = 'PENDING'
                  ''')
                  approved_pending = cursor.fetchone()[0]
                  
                  return {
                      'status': 'healthy',
                      'pending_validation': pending_validation,
                      'approved_pending': approved_pending,
                      'timestamp': datetime.now().isoformat()
                  }
              except Exception as e:
                  return {'status': 'unhealthy', 'error': str(e)}
              finally:
                  if conn:
                      conn.close()
          
          @app.on_event('startup')
          async def startup_event():
              logger.info('Starting LLM Validation Service...')
              
              # Start validation worker
              def validation_worker():
                  while True:
                      try:
                          validate_pending_recommendations()
                          time.sleep(60)  # Validate every minute
                      except Exception as e:
                          logger.error(f'Error in validation worker: {e}')
                          time.sleep(60)
              
              threading.Thread(target=validation_worker, daemon=True).start()
              logger.info('LLM Validation Service started')
          
          if __name__ == '__main__':
              uvicorn.run(app, host='0.0.0.0', port=8026)
          "
        envFrom:
        - configMapRef:
            name: trade-exec-coinbase-config
        env:
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: trade-exec-coinbase-secrets
              key: DB_PASSWORD
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8026
          initialDelaySeconds: 30
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 8026
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
---
apiVersion: v1
kind: Service
metadata:
  name: llm-validation-service
  namespace: crypto-trading
  labels:
    app: llm-validation-service
spec:
  selector:
    app: llm-validation-service
  ports:
    - protocol: TCP
      port: 8026
      targetPort: 8026
  type: ClusterIP
